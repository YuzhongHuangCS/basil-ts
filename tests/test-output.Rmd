---
title: "RCT test output"
author: "Andreas Beger, Predictive Heuristics"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_depth: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library("tidyverse")
library("forecast")
library("stringr")

source("../basil-ts/ts-forecast.R")
```

# Are the base models estimating and without obvious mistakes?

```{r, warning=FALSE}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

summary_table <- list()
for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  this_ifp <- list()
  if (!is.null(response$message)) {
    this_ifp <- data.frame(IFP = request_no, 
                           Model = "ARIMA", 
                           Estimated = FALSE, 
                           h = NA,
                           lambda = NA,
                           time_period = NA,
                           stringsAsFactors = FALSE)
  } else {
    this_ifp <- data.frame(IFP = request_no, 
                           Model = "ARIMA",  
                           Estimated = TRUE, 
                           h = response$internal2$h,
                           lambda = ifelse(length(response$internal2$lambda)==0, NA_integer_, response$internal2$lambda),
                           time_period = response$internal2$question_period$period,
                           data_aggregated = response$internal2$was_data_aggregated,
                           partial_train = response$internal2$partial_train,
                           partial_outcome = response$internal2$partial_outcome,
                           stringsAsFactors = FALSE)
  }
  this_ifp <- bind_rows(this_ifp)
  
  summary_table <- c(summary_table, list(this_ifp))
}
summary_table <- bind_rows(summary_table)
summary_table %>% 
  mutate(IFP = as.integer(IFP)) %>%
  arrange(IFP) %>%
  knitr::kable(digits = 2)

error_ifps <- summary_table$IFP[summary_table$Estimated==FALSE]
erorr_requests <- sapply(error_ifps, function(x) output_list[str_detect(output_list, x)])
error_table <- list()
for (fh in erorr_requests) {
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  err <- response$r_error_message %>% 
      str_replace_all(., "\\n", "") %>%
      str_replace_all(., "[ ]{2,}", " ") %>%
      str_replace_all(., " :", ":") %>%
      substr(., 10, 100)
  this_ifp <- data.frame(
    IFP = str_extract(fh, "[0-9]+"),
    Error = err
  )
  error_table <- c(error_table, list(this_ifp))
}
error_table <- bind_rows(error_table)
error_table %>% 
  arrange(IFP) %>%
  knitr::kable(digits = 2)

error_ifps <- summary_table$IFP[summary_table$Estimated==FALSE]
erorr_requests <- sapply(error_ifps, function(x) output_list[str_detect(output_list, x)])
error_table <- list()
for (fh in erorr_requests) {
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  err <- response$r_error_message %>% 
      str_replace_all(., "\\n", "") %>%
      str_replace_all(., "[ ]{2,}", " ") %>%
      str_replace_all(., " :", ":") %>%
      substr(., 10, 100)
  this_ifp <- data.frame(
    IFP = str_extract(fh, "[0-9]+"),
    Error = err
  )
  error_table <- c(error_table, list(this_ifp))
}
error_table <- bind_rows(error_table)
error_table %>% 
  arrange(IFP) %>%
  knitr::kable(digits = 2)
```

```{r arima-plots, warning = FALSE, fig.height=3, results = 'asis'}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

error_plot <- function(fcast, target, request_no, request) {
  y_pos <- (max(target$value, na.rm = TRUE) + mean(target$value, na.rm = TRUE)) / 2
  p <- ggplot(target, aes(x = date, y = value)) +
    geom_line() +
    theme_minimal() +
    ggtitle(sprintf("Request %s", request_no), subtitle = request$ifp$name) +
    labs(x = "", y = "") +
    geom_text(x = target$date[1], y = y_pos, col = "gray50",
              label = fcast$r_error_message %>% str_wrap(), hjust = 0)
  p
}

for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  cat(sprintf("\n\n## Request %s\n\n", request_no))
  cat(sprintf("\n\n %s \n\n", request$ifp$name))
  
  target <- data.frame(
    date  = as.Date(request$payload$historical_data$ts[, 1]),
    value = as.numeric(request$payload$historical_data$ts[, 2])
  )
  
  ifp_name        <- request$ifp$name
  question_period <- parse_question_period(ifp_name)
  data_period     <- parse_data_period(target$date)
  series_type     <- guess_series_type(target$value, ifp_name)
  
  if (data_period$period$period=="day" & question_period$period$period=="fixed") {

    target$index_date <- norm_fixed_period(target$date, 
                                           question_period$period$days,
                                           question_period$dates[1])
    
    # Aggregate data
    if (series_type=="count") {
      new_target <- aggregate(target[, c("value")], by = list(target$index_date), FUN = sum)
      colnames(new_target) <- c("date", "value")
    } else if (series_type=="continuous") {
      new_target <- aggregate(target[, c("value")], by = list(target$index_date), FUN = mean)
      colnames(new_target) <- c("date", "value")
    } else {
      stop("No method for aggregating data")
    }
    
    # update internal data
    target      <- new_target
    data_period <- parse_data_period(target$date)
    was_data_aggregated <- TRUE
  }
  
  if (!is.null(response$message)) {
    p <- error_plot(response, target, request_no, request)
    print(p)
  } else {
    ff <- response
    fcast <- data.frame(
      date = as.Date(ff$ts[, 1]),
      mean = as.numeric(ff$ts[, 2]),
      lower = as.numeric(ff$ts[, 3]),
      upper = as.numeric(ff$ts[, 4])
    )
    
    h = nrow(fcast)
    target_i <- target %>% 
      tail(h*5 + 20) %>%
      gather(var, value, value)
    fcast_i <- fcast %>%
      gather(var, value, -date)
    df <- bind_rows(target_i, fcast_i) %>%
      spread(var, value)
    
    p <- ggplot(df, aes(x = date)) +
      geom_line(aes(y = value)) + 
      theme_minimal() +
      ggtitle(sprintf("%s", ff$model)) +
      labs(x = "", y = "")
    # forecast is for single date, this does not plot with geom_ribbon
    if (nrow(fcast_i)==3) {
      p <- p + 
        geom_segment(aes(xend = date, y = lower, yend = upper), color = "lightblue") +
        geom_point(aes(y = mean), color = "blue")
    } else {
      p <- p + 
        geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue") +
        geom_line(aes(y = mean), color = "blue")
    }
    
    print(p)
  }
  
  cat("\n\n \\bigskip \n\n")
}
```


# Summary table for all models and all IFPs

```{r summary-all-models, warning=FALSE}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

summary_table <- list()
for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  this_ifp <- list()
  if (!is.null(response$message)) {
    this_ifp <- data.frame(IFP = request_no, Model = "All models", Estimated = 0, RMSE = NA)
  } else {
    for (model in response$forecasts) {
      this_model <- data.frame(IFP = request_no, Model = model$model)
      this_model$Estimated <- as.integer(is.null(model$message))
      this_model$RMSE <- model$internal$rmse
      this_ifp <- c(this_ifp, list(this_model))
    }
  }
  this_ifp <- bind_rows(this_ifp)
  
  summary_table <- c(summary_table, list(this_ifp))
}
summary_table <- bind_rows(summary_table)
summary_table %>% knitr::kable(digits = 2)
```

\clearpage

# Plot forecasts for all models and all IFPs

```{r plots-all-models, warning = FALSE, fig.height=3, results = 'asis'}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

error_plot <- function(fcast, target, request_no, request) {
  y_pos <- (max(target$value, na.rm = TRUE) + mean(target$value, na.rm = TRUE)) / 2
  p <- ggplot(target, aes(x = date, y = value)) +
    geom_line() +
    theme_minimal() +
    ggtitle(sprintf("Request %s", request_no), subtitle = request$ifp$name) +
    labs(x = "", y = "") +
    geom_text(x = target$date[1], y = y_pos, col = "gray50",
              label = fcast$r_error_message %>% str_wrap(), hjust = 0)
  p
}

for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  cat(sprintf("\n\n## Request %s\n\n", request_no))
  cat(sprintf("\n\n %s \n\n", request$ifp$name))
  
  target <- data.frame(
    date  = as.Date(request$payload$historical_data$ts[, 1]),
    value = as.numeric(request$payload$historical_data$ts[, 2])
  )
  
  ifp_name        <- request$ifp$name
  question_period <- parse_question_period(ifp_name)
  data_period     <- parse_data_period(target$date)
  series_type     <- guess_series_type(target$value, ifp_name)
  
  if (data_period$period$period=="day" & question_period$period$period=="fixed") {

    target$index_date <- norm_fixed_period(target$date, 
                                           question_period$period$days,
                                           question_period$dates[1])
    
    # Aggregate data
    if (series_type=="count") {
      new_target <- aggregate(target[, c("value")], by = list(target$index_date), FUN = sum)
      colnames(new_target) <- c("date", "value")
    } else if (series_type=="continuous") {
      new_target <- aggregate(target[, c("value")], by = list(target$index_date), FUN = mean)
      colnames(new_target) <- c("date", "value")
    } else {
      stop("No method for aggregating data")
    }
    
    # update internal data
    target      <- new_target
    data_period <- parse_data_period(target$date)
    was_data_aggregated <- TRUE
  }
  
  
  if (!is.null(response$message)) {
    p <- error_plot(response, target, request_no, request)
    print(p)
  } else {
    # loop over forecasts and again, show error message if appropriate, else plot
    for (ff in response$forecasts) {
      
      if (!is.null(ff$message)) {
        p <- error_plot(ff, target, request_no, request)
        print(p)
      } else {
        
        fcast <- data.frame(
          date = as.Date(ff$ts[, 1]),
          mean = as.numeric(ff$ts[, 2]),
          lower = as.numeric(ff$ts[, 3]),
          upper = as.numeric(ff$ts[, 4])
        )
        
        h = nrow(fcast)
        target_i <- target %>% 
          tail(h*5 + 20) %>%
          gather(var, value, value)
        fcast_i <- fcast %>%
          gather(var, value, -date)
        df <- bind_rows(target_i, fcast_i) %>%
          spread(var, value)
        
        p <- ggplot(df, aes(x = date)) +
          geom_line(aes(y = value)) + 
          theme_minimal() +
          ggtitle(sprintf("%s", ff$model)) +
          labs(x = "", y = "")
        # forecast is for single date, this does not plot with geom_ribbon
        if (nrow(fcast_i)==3) {
          p <- p + 
            geom_segment(aes(xend = date, y = lower, yend = upper), color = "lightblue") +
            geom_point(aes(y = mean), color = "blue")
        } else {
          p <- p + 
            geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue") +
            geom_line(aes(y = mean), color = "blue")
        }
        
        print(p)
      }
    }
  }
  
  cat("\n\n \\clearpage \n\n")
}
```



