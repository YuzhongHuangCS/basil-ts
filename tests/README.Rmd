---
title: "RCT test output"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: yes
    toc_depth: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library("tidyverse")
library("forecast")
library("stringr")
library("cowplot")

source("../basil-ts/ts-forecast.R")
```

# Are the base models estimating and without obvious mistakes?

```{r, warning=FALSE}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

summary_table <- list()
for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  this_ifp <- list()
  if (!is.null(response$message)) {
    this_ifp <- data.frame(
      IFP = request_no, 
      Model = "ARIMA", 
      N = NA,
      h = NA,
      lambda = NA,
      stringsAsFactors = FALSE)
  } else {
    this_ifp <- data.frame(
      IFP = request_no, 
      Model = "ARIMA",  
      time = response$internal2$question_period$period,
      data_type = response$internal2$series_type,
      N = response$trainN,
      h = response$internal2$h,
      lambda = ifelse(
        length(response$internal2$lambda)==0, 
        NA_integer_, 
        response$internal2$lambda),
      data_agg = ifelse(
        response$internal2$was_data_aggregated,
        "yes",
        "no"),
      partial_train = response$internal2$partial_train,
      partial_y = ifelse(
        response$internal2$partial_outcome,
        "yes",
        "no"),
      stringsAsFactors = FALSE)
  }
  this_ifp <- bind_rows(this_ifp)
  
  summary_table <- c(summary_table, list(this_ifp))
}
summary_table <- bind_rows(summary_table)
summary_table %>% 
  mutate(IFP = as.integer(IFP)) %>%
  arrange(desc(IFP)) %>%
  select(-Model) %>%
  knitr::kable(digits = 2)

error_ifps <- summary_table$IFP[is.na(summary_table$time)]
erorr_requests <- sapply(error_ifps, function(x) output_list[str_detect(output_list, x)])
error_table <- list()
for (fh in erorr_requests) {
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  err <- response$r_error_message %>% 
      str_replace_all(., "\\n", "") %>%
      str_replace_all(., "[ ]{2,}", " ") %>%
      str_replace_all(., " :", ":") %>%
      substr(., 10, 100)
  this_ifp <- data.frame(
    IFP = str_extract(fh, "[0-9]+"),
    Error = err
  )
  error_table <- c(error_table, list(this_ifp))
}
error_table <- bind_rows(error_table)
error_table %>% 
  arrange(desc(IFP)) %>%
  knitr::kable(digits = 2)
```

# Plot ARIMA forecasts

```{r arima-plots, warning = FALSE, fig.height=3, results = 'asis'}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)
req_no <- sapply(output_list, str_extract, "[0-9]+")
output_list <- output_list[order(as.integer(req_no), decreasing = TRUE)]

error_plot <- function(fcast, target, request_no, request) {
  y_pos <- (max(target$value, na.rm = TRUE) + mean(target$value, na.rm = TRUE)) / 2
  p <- ggplot(target, aes(x = date, y = value)) +
    geom_line() +
    theme_minimal() +
    #ggtitle(sprintf("Request %s", request_no), subtitle = request$ifp$name) +
    labs(x = "", y = "") +
    geom_text(x = target$date[1], y = y_pos, col = "gray50",
              label = fcast$r_error_message %>% str_wrap(), hjust = 0)
  p
}

for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  cat(sprintf("\n\n## Request %s\n\n", request_no))
  cat(sprintf("\n\n %s \n\n", request$ifp$name))
  
  target <- data.frame(
    date  = as.Date(request$payload$historical_data$ts[, 1]),
    value = as.numeric(request$payload$historical_data$ts[, 2])
  )
  
  ifp_name        <- request$ifp$name
  binary_ifp <- request$ifp$`binary?`
  validate_seps(request$payload$separations$values)
  
  # Parse characteristics
  question_period <- parse_question_period(ifp_name)
  data_period     <- parse_data_period(target$date)
  series_type     <- guess_series_type(target$value, ifp_name)
  options         <- parse_separations(request$payload$separations, 
                                       series_type, ifp_name)
  agg_method      <- determine_aggregation_method(series_type, ifp_name)
  
  # Do aggregation if neccessary
  was_data_aggregated <- FALSE
  were_dates_shifted  <- FALSE
  if (data_period$period$period=="day" & question_period$period$period=="fixed") {
    # update internal data
    target      <- aggregate_data(target, question_period, agg_method)
    data_period <- parse_data_period(target$date)
    was_data_aggregated <- TRUE
  }
  
  if (!is.null(response$message)) {
    p <- error_plot(response, target, request_no, request)
    print(p)
  } else {
    ff <- response
    fcast <- data.frame(
      date = as.Date(ff$ts[, 1]),
      mean = as.numeric(ff$ts[, 2]),
      lower = as.numeric(ff$ts[, 3]),
      upper = as.numeric(ff$ts[, 4])
    )
    
    h = nrow(fcast)
    target_i <- target %>% 
      tail(ff$trainN) %>%
      gather(var, value, value)
    fcast_i <- fcast %>%
      gather(var, value, -date)
    fcast_end <- fcast_i %>%
      filter(date==max(date)) %>%
      mutate(date = as.Date(ff$to_date))
    df <- bind_rows(target_i, fcast_i, fcast_end) %>%
      spread(var, value)
    
    subt <- sprintf("N = %s, h = %s", response$trainN, response$internal2$h)
    if (response$internal2$partial_train %in% c("used", "discarded")) {
      subt <- paste0(
        subt, 
        sprintf(", partial train to %s (%s)", 
                as.character( response$internal2$last_event_date),
                response$internal2$partial_train))
    } else if (response$internal2$partial_outcome) {
      subt <- paste0(
        subt,
        sprintf(", partial outcomne to %s",
                as.character( response$internal2$last_event_date)))
    }
    cutpoints <- options$cutpoints %>% head(-1) %>% tail(-1)
    p <- ggplot(df, aes(x = date)) +
      geom_line(aes(y = value)) + 
      theme_minimal() +
      ggtitle(sprintf("%s", request_no),
              subtitle = subt) +
      labs(x = "", y = "") +
      geom_hline(yintercept = cutpoints, linetype = 3)
    p <- p + 
        geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue") +
        geom_line(aes(y = mean), color = "blue")

    # Plot the options
    op <- ff$option_probabilities
    extend <- if (length(cutpoints) > 1) mean(diff(cutpoints)) else 1
    op_labels <- options$values
    if (str_detect(op_labels[1], ">")) {
      op <- rev(op)
      op_labels <- rev(op_labels)
    }
    if (binary_ifp) {
      op <- rev(c(op, 1 - op))
      op_labels <- rev(c("yes", "no"))
    }
    
    cut_df <- data.frame(
      option = factor(op_labels, levels = op_labels),
      p = op
    )
    p2 <- ggplot(cut_df, aes(x = option, y = p)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      theme_minimal() +
      labs(x = "", y = "") +
      scale_y_continuous(breaks = c(0, round(max(op), 2)))
    
    print(plot_grid(p, p2, rel_widths = c(3, 1)))
  }
  
  cat("\n\n")
}
```



```{r summary-all-models, eval = FALSE, warning=FALSE}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

summary_table <- list()
for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  this_ifp <- list()
  if (!is.null(response$message)) {
    this_ifp <- data.frame(IFP = request_no, Model = "All models", Estimated = 0, RMSE = NA)
  } else {
    for (model in response$forecasts) {
      this_model <- data.frame(IFP = request_no, Model = model$model)
      this_model$Estimated <- as.integer(is.null(model$message))
      this_model$RMSE <- model$internal$rmse
      this_ifp <- c(this_ifp, list(this_model))
    }
  }
  this_ifp <- bind_rows(this_ifp)
  
  summary_table <- c(summary_table, list(this_ifp))
}
summary_table <- bind_rows(summary_table)
summary_table %>% knitr::kable(digits = 2)
```



```{r plots-all-models, eval = FALSE, warning = FALSE, fig.height=3, results = 'asis'}
output_list <- dir("io", pattern = "_output_", full.names = TRUE)

error_plot <- function(fcast, target, request_no, request) {
  y_pos <- (max(target$value, na.rm = TRUE) + mean(target$value, na.rm = TRUE)) / 2
  p <- ggplot(target, aes(x = date, y = value)) +
    geom_line() +
    theme_minimal() +
    ggtitle(sprintf("Request %s", request_no), subtitle = request$ifp$name) +
    labs(x = "", y = "") +
    geom_text(x = target$date[1], y = y_pos, col = "gray50",
              label = fcast$r_error_message %>% str_wrap(), hjust = 0)
  p
}

for (fh in output_list) {
  input_fh <- str_replace(fh, "output", "input")
  
  response <- jsonlite::fromJSON(fh, simplifyVector = TRUE, simplifyDataFrame = FALSE)
  request  <- jsonlite::fromJSON(input_fh)
  request_no <- str_extract(fh, "[0-9]+")
  
  cat(sprintf("\n\n## Request %s\n\n", request_no))
  cat(sprintf("\n\n %s \n\n", request$ifp$name))
  
  target <- data.frame(
    date  = as.Date(request$payload$historical_data$ts[, 1]),
    value = as.numeric(request$payload$historical_data$ts[, 2])
  )
  
  ifp_name        <- request$ifp$name
  question_period <- parse_question_period(ifp_name)
  data_period     <- parse_data_period(target$date)
  series_type     <- guess_series_type(target$value, ifp_name)
  agg_method      <- determine_aggregation_method(series_type, ifp_name)
  
  if (data_period$period$period=="day" & question_period$period$period=="fixed") {

    target$index_date <- norm_fixed_period(target$date, 
                                           question_period$period$days,
                                           question_period$dates[1])
    
    # Do aggregation if neccessary
    was_data_aggregated <- FALSE
    were_dates_shifted  <- FALSE
    if (data_period$period$period=="day" & question_period$period$period=="fixed") {
      # update internal data
      target      <- aggregate_data(target, question_period, agg_method)
      data_period <- parse_data_period(target$date)
      was_data_aggregated <- TRUE
    }
  }
  
  
  if (!is.null(response$message)) {
    p <- error_plot(response, target, request_no, request)
    print(p)
  } else {
    # loop over forecasts and again, show error message if appropriate, else plot
    for (ff in response$forecasts) {
      
      if (!is.null(ff$message)) {
        p <- error_plot(ff, target, request_no, request)
        print(p)
      } else {
        
        fcast <- data.frame(
          date = as.Date(ff$ts[, 1]),
          mean = as.numeric(ff$ts[, 2]),
          lower = as.numeric(ff$ts[, 3]),
          upper = as.numeric(ff$ts[, 4])
        )
        
        h = nrow(fcast)
        target_i <- target %>% 
          tail(h*5 + 20) %>%
          gather(var, value, value)
        fcast_i <- fcast %>%
          gather(var, value, -date)
        df <- bind_rows(target_i, fcast_i) %>%
          spread(var, value)
        
        p <- ggplot(df, aes(x = date)) +
          geom_line(aes(y = value)) + 
          theme_minimal() +
          ggtitle(sprintf("%s", ff$model)) +
          labs(x = "", y = "")
        # forecast is for single date, this does not plot with geom_ribbon
        if (nrow(fcast_i)==3) {
          p <- p + 
            geom_segment(aes(xend = date, y = lower, yend = upper), color = "lightblue") +
            geom_point(aes(y = mean), color = "blue")
        } else {
          p <- p + 
            geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue") +
            geom_line(aes(y = mean), color = "blue")
        }
        
        print(p)
      }
    }
  }
  
  cat("\n\n \\clearpage \n\n")
}
```



